FlowScript {
  // Document Structure
  Document = Line*
  Line = BlankLine | RelationshipExpression | Element

  Element = Modifier* Content
  Content = State | Insight | Question | Completion | Alternative | Block | Statement

  BlankLine = space* "\n"
  Statement = ~Modifier (~("\n" | "{" | "}") any)+ "\n"?

  // Blocks (thought blocks / atomic processing units)
  Block = "{" ws BlockContent? ws "}"
  BlockContent = BlockLine (separator? BlockLine)* separator?
  BlockLine = ws (ContinuationRel | RelationshipExpression | BlockElement)
  BlockElement = Modifier* BlockContent_inner
  BlockContent_inner = State | Insight | Question | Completion | Alternative | Block | BlockStatement
  BlockStatement = ~Modifier (~("\n" | "{" | "}" | ";") any)+
  separator = (space | "\n" | ";")+
  ws = (space | "\n")*

  // Relationship Expressions (must come before Statement in Line)
  RelationshipExpression = RelNode RelOpNodePair+
  RelOpNodePair = RelOp RelNode
  RelNode = space* (Block | NodeText) space*

  // Continuation Relationship (only valid inside blocks)
  ContinuationRel = RelOp space* RelNode

  NodeText = ~insightPrefix (~("<->" | "->" | "<-" | "=>" | "><[" | "><" | "\n" | "{" | "}" | ";") any)+
  insightPrefix = "thought:" | "action:"

  RelOp = bidirectional | reverseCausal | causal | temporal | tensionWithAxis | tensionWithoutAxis

  bidirectional = "<->"
  reverseCausal = "<-"
  causal = "->"
  temporal = "=>"
  tensionWithAxis = "><[" axisLabel "]"
  tensionWithoutAxis = "><"

  axisLabel = (~"]" any)+

  // Modifiers (highest precedence)
  Modifier = urgent | strongPositive | highConfidence | lowConfidence

  urgent = "!"
  strongPositive = "++"
  highConfidence = "*"
  lowConfidence = "~"

  // State markers
  State = decidedWithFields | decidedWithoutFields
        | blockedWithFields | blockedWithoutFields
        | parkingWithFields | parkingWithoutFields
        | exploring

  decidedWithFields = "[decided(" decidedFields? ")]"
  decidedFields = decidedField (space* "," space* decidedField)*
  decidedField = rationalField | onField
  rationalField = "rationale:" space* string
  onField = "on:" space* dateString

  decidedWithoutFields = "[decided]"

  blockedWithFields = "[blocked(" blockedFields? ")]"
  blockedFields = blockedField (space* "," space* blockedField)*
  blockedField = reasonField | sinceField
  reasonField = "reason:" space* string
  sinceField = "since:" space* dateString

  blockedWithoutFields = "[blocked]"

  parkingWithFields = "[parking(" parkingFields? ")]"
  parkingFields = parkingField (space* "," space* parkingField)*
  parkingField = whyField | untilField
  whyField = "why:" space* string
  untilField = "until:" space* string

  parkingWithoutFields = "[parking]"

  exploring = "[exploring]"

  // Insights, Questions, Commands
  Insight = Thought | Action

  // Insights can have optional relationship chains, or blocks
  // Supports: text+block, just block, or just text
  Thought = "thought:" space* thoughtText? Block? RelOpNodePair* "\n"?
  Action = "action:" space* actionText? Block? RelOpNodePair* "\n"?

  // Content excludes relationship operators and block delimiters (they're in RelOpNodePair)
  // For text+block pattern, exclude { as well
  thoughtText = (~("\n" | "}" | "{" | "->" | "<-" | "<=>" | "=>" | "><[" | "><") any)+
  actionText = (~("\n" | "}" | "{" | "->" | "<-" | "<=>" | "=>" | "><[" | "><") any)+

  Question = "?" space* questionText? Block? "\n"?
  questionText = (~("\n" | "}" | "{") any)+

  Completion = "âœ“" space* completionText? Block? "\n"?
  completionText = (~("\n" | "}" | "{") any)+

  // Alternatives
  Alternative = "||" space* alternativeText? Block? "\n"?
  alternativeText = (~("\n" | "}" | "{") any)+

  // Lexical elements
  string = "\"" stringChar* "\""
  stringChar = ~("\"" | "\\") any
             | escapeSequence

  escapeSequence = "\\" ("\"" | "\\" | "n" | "t" | "r")

  dateString = "\"" isoDate "\""
  isoDate = digit digit digit digit "-" digit digit "-" digit digit
           ("T" digit digit ":" digit digit ":" digit digit "Z")?

  identifier = letter (letter | digit | "_" | "-")*

  // Lexical rules (whitespace handling)
  space := " " | "\t" | "\r"
}
